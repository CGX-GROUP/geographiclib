<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>GeographicLib: TransverseMercator.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_ad447d6b68b576de564aa48f01fcf618.html">src</a>
  </div>
</div>
<div class="contents">
<h1>TransverseMercator.cpp</h1><a href="TransverseMercator_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment"> * \file TransverseMercator.cpp</span>
<a name="l00003"></a>00003 <span class="comment"> * \brief Implementation for GeographicLib::TransverseMercator class</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Copyright (c) Charles Karney (2008, 2009, 2010) &lt;charles@karney.com&gt;</span>
<a name="l00006"></a>00006 <span class="comment"> * and licensed under the LGPL.  For more information, see</span>
<a name="l00007"></a>00007 <span class="comment"> * http://geographiclib.sourceforge.net/</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * This implementation follows closely</span>
<a name="l00010"></a>00010 <span class="comment"> * &lt;a href="http://www.jhs-suositukset.fi/suomi/jhs154"&gt; JHS 154, ETRS89 -</span>
<a name="l00011"></a>00011 <span class="comment"> * j&amp;auml;rjestelm&amp;auml;&amp;auml;n liittyv&amp;auml;t karttaprojektiot,</span>
<a name="l00012"></a>00012 <span class="comment"> * tasokoordinaatistot ja karttalehtijako&lt;/a&gt; (Map projections, plane</span>
<a name="l00013"></a>00013 <span class="comment"> * coordinates, and map sheet index for ETRS89), published by JUHTA, Finnish</span>
<a name="l00014"></a>00014 <span class="comment"> * Geodetic Institute, and the National Land Survey of Finland (2006).</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * The relevant section is available as the 2008 PDF file</span>
<a name="l00017"></a>00017 <span class="comment"> * http://docs.jhs-suositukset.fi/jhs-suositukset/JHS154/JHS154_liite1.pdf</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> * This is a straight transcription of the formulas in this paper with the</span>
<a name="l00020"></a>00020 <span class="comment"> * following exceptions:</span>
<a name="l00021"></a>00021 <span class="comment"> *  - use of 6th order series instead of 4th order series.  This reduces the</span>
<a name="l00022"></a>00022 <span class="comment"> *    error to about 5nm for the UTM range of coordinates (instead of 200nm),</span>
<a name="l00023"></a>00023 <span class="comment"> *    with a speed penalty of only 1%;</span>
<a name="l00024"></a>00024 <span class="comment"> *  - use Newton's method instead of plain iteration to solve for latitude in</span>
<a name="l00025"></a>00025 <span class="comment"> *    terms of isometric latitude in the Reverse method;</span>
<a name="l00026"></a>00026 <span class="comment"> *  - use of Horner's representation for evaluating polynomials and Clenshaw's</span>
<a name="l00027"></a>00027 <span class="comment"> *    method for summing trigonometric series;</span>
<a name="l00028"></a>00028 <span class="comment"> *  - several modifications of the formulas to improve the numerical accuracy;</span>
<a name="l00029"></a>00029 <span class="comment"> *  - evaluating the convergence and scale using the expression for the</span>
<a name="l00030"></a>00030 <span class="comment"> *    projection or its inverse.</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> * If the preprocessor variable TM_TX_MAXPOW is set to an integer between 4 and</span>
<a name="l00033"></a>00033 <span class="comment"> * 8, then this specifies the order of the series used for the forward and</span>
<a name="l00034"></a>00034 <span class="comment"> * reverse transformations.  The default value is 6.  (The series accurate to</span>
<a name="l00035"></a>00035 <span class="comment"> * 12th order is given in \ref tmseries.)</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> * Other equivalent implementations are given in</span>
<a name="l00038"></a>00038 <span class="comment"> *  - http://www.ign.fr/DISPLAY/000/526/702/5267021/NTG_76.pdf</span>
<a name="l00039"></a>00039 <span class="comment"> *  - http://www.lantmateriet.se/upload/filer/kartor/geodesi_gps_och_detaljmatning/geodesi/Formelsamling/Gauss_Conformal_Projection.pdf</span>
<a name="l00040"></a>00040 <span class="comment"> **********************************************************************/</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include "<a class="code" href="TransverseMercator_8hpp.html" title="Header for GeographicLib::TransverseMercator class.">GeographicLib/TransverseMercator.hpp</a>"</span>
<a name="l00043"></a>00043 
<a name="l00044"></a><a class="code" href="TransverseMercator_8cpp.html#b09ba83d5531a4ca91dc8ce82ae98084">00044</a> <span class="preprocessor">#define GEOGRAPHICLIB_TRANSVERSEMERCATOR_CPP "$Id: TransverseMercator.cpp 6785 2010-01-05 22:15:42Z karney $"</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <a class="code" href="Constants_8hpp.html#f90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="TransverseMercator_8cpp.html#b09ba83d5531a4ca91dc8ce82ae98084">GEOGRAPHICLIB_TRANSVERSEMERCATOR_CPP</a>)
<a name="l00047"></a>00047 <a class="code" href="Constants_8hpp.html#f90fa899707a2ac513d5e4c76853bbf5">RCSID_DECL</a>(<a class="code" href="TransverseMercator_8hpp.html#bbbe2faaff284db3183ddf3afcbf5623">GEOGRAPHICLIB_TRANSVERSEMERCATOR_HPP</a>)
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 namespace GeographicLib {
<a name="l00050"></a>00050 
<a name="l00051"></a>00051   <span class="keyword">using namespace </span>std;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053   <span class="keyword">const</span> <a class="code" href="Geod_8cpp.html#5caf95d46b184d9ca1d3764b3781b3c9">Math::real</a> TransverseMercator::tol =
<a name="l00054"></a>00054     <a class="code" href="Geod_8cpp.html#5caf95d46b184d9ca1d3764b3781b3c9">real</a>(0.1)*sqrt(numeric_limits&lt;real&gt;::epsilon());
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="classGeographicLib_1_1TransverseMercator.html#1322ba37e8f01d724f9da1dfd94d91d7">00056</a>   TransverseMercator::TransverseMercator(<a class="code" href="Geod_8cpp.html#5caf95d46b184d9ca1d3764b3781b3c9">real</a> a, <a class="code" href="Geod_8cpp.html#5caf95d46b184d9ca1d3764b3781b3c9">real</a> r, <a class="code" href="Geod_8cpp.html#5caf95d46b184d9ca1d3764b3781b3c9">real</a> k0)
<a name="l00057"></a>00057     : _a(a)
<a name="l00058"></a>00058     , _r(r)
<a name="l00059"></a>00059     , _f(_r != 0 ? 1 / _r : 0)
<a name="l00060"></a>00060     , _k0(k0)
<a name="l00061"></a>00061     , _e2(_f * (2 - _f))
<a name="l00062"></a>00062     , _e(sqrt(abs(_e2)))
<a name="l00063"></a>00063     , _e2m(1 - _e2)
<a name="l00064"></a>00064       <span class="comment">// _c = sqrt( pow(1 + _e, 1 + _e) * pow(1 - _e, 1 - _e) ) )</span>
<a name="l00065"></a>00065       <span class="comment">// See, for example, Lee (1976), p 100.</span>
<a name="l00066"></a>00066     , _c( sqrt(_e2m) * exp(eatanhe(<a class="code" href="Geod_8cpp.html#5caf95d46b184d9ca1d3764b3781b3c9">real</a>(1))) )
<a name="l00067"></a>00067     , _n(_f / (2 - _f))
<a name="l00068"></a>00068   {
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (!(_a &gt; 0))
<a name="l00070"></a>00070       <span class="keywordflow">throw</span> <a class="code" href="classGeographicLib_1_1GeographicErr.html" title="Exception handling for GeographicLib">GeographicErr</a>(<span class="stringliteral">"Major radius is not positive"</span>);
<a name="l00071"></a>00071     <span class="keywordflow">if</span> (!(_k0 &gt; 0))
<a name="l00072"></a>00072       <span class="keywordflow">throw</span> <a class="code" href="classGeographicLib_1_1GeographicErr.html" title="Exception handling for GeographicLib">GeographicErr</a>(<span class="stringliteral">"Scale is not positive"</span>);
<a name="l00073"></a>00073     <span class="comment">// If coefficents might overflow an int, convert them to double (and they</span>
<a name="l00074"></a>00074     <span class="comment">// are all exactly representable as doubles).</span>
<a name="l00075"></a>00075     <span class="keywordflow">switch</span> (maxpow) {
<a name="l00076"></a>00076     <span class="keywordflow">case</span> 4:
<a name="l00077"></a>00077       _b1 = 1/(1+_n)*(sq(_n)*(sq(_n)+16)+64)/64;
<a name="l00078"></a>00078       _h[0] = _n*(_n*((555-4*_n)*_n-960)+720)/1440;
<a name="l00079"></a>00079       _h[1] = sq(_n)*((96-437*_n)*_n+30)/1440;
<a name="l00080"></a>00080       _h[2] = (119-148*_n)*sq(_n)*_n/3360;
<a name="l00081"></a>00081       _h[3] = 4397*sq(sq(_n))/161280;
<a name="l00082"></a>00082       _hp[0] = _n*(_n*(_n*(164*_n+225)-480)+360)/720;
<a name="l00083"></a>00083       _hp[1] = sq(_n)*(_n*(557*_n-864)+390)/1440;
<a name="l00084"></a>00084       _hp[2] = (427-1236*_n)*sq(_n)*_n/1680;
<a name="l00085"></a>00085       _hp[3] = 49561*sq(sq(_n))/161280;
<a name="l00086"></a>00086       <span class="keywordflow">break</span>;
<a name="l00087"></a>00087     <span class="keywordflow">case</span> 5:
<a name="l00088"></a>00088       _b1 = 1/(1+_n)*(sq(_n)*(sq(_n)+16)+64)/64;
<a name="l00089"></a>00089       _h[0] = _n*(_n*(_n*((-3645*_n-64)*_n+8880)-15360)+11520)/23040;
<a name="l00090"></a>00090       _h[1] = sq(_n)*(_n*(_n*(4416*_n-3059)+672)+210)/10080;
<a name="l00091"></a>00091       _h[2] = sq(_n)*_n*((-627*_n-592)*_n+476)/13440;
<a name="l00092"></a>00092       _h[3] = (4397-3520*_n)*sq(sq(_n))/161280;
<a name="l00093"></a>00093       _h[4] = 4583*sq(sq(_n))*_n/161280;
<a name="l00094"></a>00094       _hp[0] = _n*(_n*(_n*((328-635*_n)*_n+450)-960)+720)/1440;
<a name="l00095"></a>00095       _hp[1] = sq(_n)*(_n*(_n*(4496*_n+3899)-6048)+2730)/10080;
<a name="l00096"></a>00096       _hp[2] = sq(_n)*_n*(_n*(15061*_n-19776)+6832)/26880;
<a name="l00097"></a>00097       _hp[3] = (49561-171840*_n)*sq(sq(_n))/161280;
<a name="l00098"></a>00098       _hp[4] = 34729*sq(sq(_n))*_n/80640;
<a name="l00099"></a>00099       <span class="keywordflow">break</span>;
<a name="l00100"></a>00100     <span class="keywordflow">case</span> 6:
<a name="l00101"></a>00101       _b1 = 1/(1+_n)*(sq(_n)*(sq(_n)*(sq(_n)+4)+64)+256)/256;
<a name="l00102"></a>00102       _h[0] = _n*(_n*(_n*(_n*(_n*(384796*_n-382725)-6720)+932400)-1612800)+
<a name="l00103"></a>00103                   1209600)/2419200;
<a name="l00104"></a>00104       _h[1] = sq(_n)*(_n*(_n*((1695744-1118711*_n)*_n-1174656)+258048)+80640)/
<a name="l00105"></a>00105         3870720;
<a name="l00106"></a>00106       _h[2] = sq(_n)*_n*(_n*(_n*(22276*_n-16929)-15984)+12852)/362880;
<a name="l00107"></a>00107       _h[3] = sq(sq(_n))*((-830251*_n-158400)*_n+197865)/7257600;
<a name="l00108"></a>00108       _h[4] = (453717-435388*_n)*sq(sq(_n))*_n/15966720;
<a name="l00109"></a>00109       _h[5] = 20648693*sq(sq(_n))*sq(_n)/638668800;
<a name="l00110"></a>00110       _hp[0] = _n*(_n*(_n*(_n*(_n*(31564*_n-66675)+34440)+47250)-100800)+
<a name="l00111"></a>00111                    75600)/151200;
<a name="l00112"></a>00112       _hp[1] = sq(_n)*(_n*(_n*((863232-1983433*_n)*_n+748608)-1161216)+524160)/
<a name="l00113"></a>00113         1935360;
<a name="l00114"></a>00114       _hp[2] = sq(_n)*_n*(_n*(_n*(670412*_n+406647)-533952)+184464)/725760;
<a name="l00115"></a>00115       _hp[3] = sq(sq(_n))*(_n*(6601661*_n-7732800)+2230245)/7257600;
<a name="l00116"></a>00116       _hp[4] = (3438171-13675556*_n)*sq(sq(_n))*_n/7983360;
<a name="l00117"></a>00117       _hp[5] = 212378941*sq(sq(_n))*sq(_n)/319334400;
<a name="l00118"></a>00118       <span class="keywordflow">break</span>;
<a name="l00119"></a>00119     <span class="keywordflow">case</span> 7:
<a name="l00120"></a>00120       _b1 = 1/(1+_n)*(sq(_n)*(sq(_n)*(sq(_n)+4)+64)+256)/256;
<a name="l00121"></a>00121       _h[0] = _n*(_n*(_n*(_n*(_n*((6156736-5406467*_n)*_n-6123600)-107520)+
<a name="l00122"></a>00122                           14918400)-25804800)+19353600)/38707200;
<a name="l00123"></a>00123       _h[1] = sq(_n)*(_n*(_n*(_n*(_n*(829456*_n-5593555)+8478720)-5873280)+
<a name="l00124"></a>00124                           1290240)+403200)/19353600;
<a name="l00125"></a>00125       _h[2] = sq(_n)*_n*(_n*(_n*(_n*(9261899*_n+3564160)-2708640)-2557440)+
<a name="l00126"></a>00126                          2056320)/58060800;
<a name="l00127"></a>00127       _h[3] = sq(sq(_n))*(_n*(_n*(14928352*_n-9132761)-1742400)+2176515)/
<a name="l00128"></a>00128         79833600;
<a name="l00129"></a>00129       _h[4] = sq(sq(_n))*_n*((-8005831*_n-1741552)*_n+1814868)/63866880;
<a name="l00130"></a>00130       _h[5] = (268433009-261810608*_n)*sq(sq(_n))*sq(_n)/8302694400.0;
<a name="l00131"></a>00131       _h[6] = 219941297*sq(sq(_n))*sq(_n)*_n/5535129600.0;
<a name="l00132"></a>00132       _hp[0] = _n*(_n*(_n*(_n*(_n*(_n*(1804025*_n+2020096)-4267200)+2204160)+
<a name="l00133"></a>00133                            3024000)-6451200)+4838400)/9676800;
<a name="l00134"></a>00134       _hp[1] = sq(_n)*(_n*(_n*(_n*(_n*(4626384*_n-9917165)+4316160)+3743040)-
<a name="l00135"></a>00135                            5806080)+2620800)/9676800;
<a name="l00136"></a>00136       _hp[2] = sq(_n)*_n*(_n*(_n*((26816480-67102379*_n)*_n+16265880)-
<a name="l00137"></a>00137                               21358080)+7378560)/29030400;
<a name="l00138"></a>00138       _hp[3] = sq(sq(_n))*(_n*(_n*(155912000*_n+72618271)-85060800)+24532695)/
<a name="l00139"></a>00139         79833600;
<a name="l00140"></a>00140       _hp[4] = sq(sq(_n))*_n*(_n*(102508609*_n-109404448)+27505368)/63866880;
<a name="l00141"></a>00141       _hp[5] = (2760926233.0-12282192400.0*_n)*sq(sq(_n))*sq(_n)/4151347200.0;
<a name="l00142"></a>00142       _hp[6] = 1522256789.0*sq(sq(_n))*sq(_n)*_n/1383782400.0;
<a name="l00143"></a>00143       <span class="keywordflow">break</span>;
<a name="l00144"></a>00144     <span class="keywordflow">case</span> 8:
<a name="l00145"></a>00145       _b1 = 1/(1+_n)*(sq(_n)*(sq(_n)*(sq(_n)*(25*sq(_n)+64)+256)+4096)+16384)/
<a name="l00146"></a>00146         16384;
<a name="l00147"></a>00147       _h[0] = _n*(_n*(_n*(_n*(_n*(_n*(_n*(31777436*_n-37845269)+43097152)-
<a name="l00148"></a>00148                                   42865200)-752640)+104428800)-180633600)+
<a name="l00149"></a>00149                   135475200)/270950400;
<a name="l00150"></a>00150       _h[1] = sq(_n)*(_n*(_n*(_n*(_n*(_n*(24749483*_n+14930208)-100683990)+
<a name="l00151"></a>00151                                   152616960)-105719040)+23224320)+7257600)/
<a name="l00152"></a>00152         348364800;
<a name="l00153"></a>00153       _h[2] = sq(_n)*_n*(_n*(_n*(_n*((101880889-232468668*_n)*_n+39205760)-
<a name="l00154"></a>00154                                  29795040)-28131840)+22619520)/638668800;
<a name="l00155"></a>00155       _h[3] = sq(sq(_n))*(_n*(_n*(_n*(324154477*_n+1433121792.0)-876745056)-
<a name="l00156"></a>00156                               167270400)+208945440)/7664025600.0;
<a name="l00157"></a>00157       _h[4] = sq(sq(_n))*_n*(_n*(_n*(457888660*_n-312227409)-67920528)+
<a name="l00158"></a>00158                              70779852)/2490808320.0;
<a name="l00159"></a>00159       _h[5] = sq(sq(_n))*sq(_n)*((-19841813847.0*_n-3665348512.0)*_n+
<a name="l00160"></a>00160                                  3758062126.0)/116237721600.0;
<a name="l00161"></a>00161       _h[6] = (1979471673.0-1989295244.0*_n)*sq(sq(_n))*sq(_n)*_n/
<a name="l00162"></a>00162         49816166400.0;
<a name="l00163"></a>00163       _h[7] = 191773887257.0*sq(sq(sq(_n)))/3719607091200.0;
<a name="l00164"></a>00164       _hp[0] = _n*(_n*(_n*(_n*(_n*(_n*((37884525-75900428*_n)*_n+42422016)-
<a name="l00165"></a>00165                                    89611200)+46287360)+63504000)-135475200)+
<a name="l00166"></a>00166                    101606400)/203212800;
<a name="l00167"></a>00167       _hp[1] = sq(_n)*(_n*(_n*(_n*(_n*(_n*(148003883*_n+83274912)-178508970)+
<a name="l00168"></a>00168                                    77690880)+67374720)-104509440)+47174400)/
<a name="l00169"></a>00169         174182400;
<a name="l00170"></a>00170       _hp[2] = sq(_n)*_n*(_n*(_n*(_n*(_n*(318729724*_n-738126169)+294981280)+
<a name="l00171"></a>00171                                   178924680)-234938880)+81164160)/319334400;
<a name="l00172"></a>00172       _hp[3] = sq(sq(_n))*(_n*(_n*((14967552000.0-40176129013.0*_n)*_n+
<a name="l00173"></a>00173                                    6971354016.0)-8165836800.0)+2355138720.0)/
<a name="l00174"></a>00174         7664025600.0;
<a name="l00175"></a>00175       _hp[4] = sq(sq(_n))*_n*(_n*(_n*(10421654396.0*_n+3997835751.0)-
<a name="l00176"></a>00176                                   4266773472.0)+1072709352.0)/2490808320.0;
<a name="l00177"></a>00177       _hp[5] = sq(sq(_n))*sq(_n)*(_n*(175214326799.0*_n-171950693600.0)+
<a name="l00178"></a>00178                                   38652967262.0)/58118860800.0;
<a name="l00179"></a>00179       _hp[6] = (13700311101.0-67039739596.0*_n)*sq(sq(_n))*sq(_n)*_n/
<a name="l00180"></a>00180         12454041600.0;
<a name="l00181"></a>00181       _hp[7] = 1424729850961.0*sq(sq(sq(_n)))/743921418240.0;
<a name="l00182"></a>00182       <span class="keywordflow">break</span>;
<a name="l00183"></a>00183     <span class="keywordflow">default</span>:
<a name="l00184"></a>00184       <a class="code" href="Constants_8hpp.html#8f24445c1bccd69b63e365aa5d5bb129">STATIC_ASSERT</a>(maxpow &gt;= 4 &amp;&amp; maxpow &lt;= 8, <span class="stringliteral">"Bad value of maxpow"</span>);
<a name="l00185"></a>00185     }
<a name="l00186"></a>00186     <span class="comment">// _a1 is the equivalent radius for computing the circumference of</span>
<a name="l00187"></a>00187     <span class="comment">// ellipse.  Relative error is f^6/16384 = 8.8e-20 for WGS84.</span>
<a name="l00188"></a>00188     _a1 = _b1 * _a;
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191   <span class="keyword">const</span> <a class="code" href="classGeographicLib_1_1TransverseMercator.html" title="Transverse Mercator Projection.">TransverseMercator</a>
<a name="l00192"></a>00192   <a class="code" href="classGeographicLib_1_1TransverseMercator.html#a25b52e35bc54c368e6c8b17e02b0542">TransverseMercator::UTM</a>(<a class="code" href="classGeographicLib_1_1Constants.html#53f39f52837f47490fbdf7332a37dd8b">Constants::WGS84_a</a>(), <a class="code" href="classGeographicLib_1_1Constants.html#199810de7ff3351be6473d20ef045789">Constants::WGS84_r</a>(),
<a name="l00193"></a>00193                           <a class="code" href="classGeographicLib_1_1Constants.html#ebbe37ebfb407a851f72caa95e5dc94f">Constants::UTM_k0</a>());
<a name="l00194"></a>00194 
<a name="l00195"></a><a class="code" href="classGeographicLib_1_1TransverseMercator.html#07d73a6d94e2434cbb937978d61a5ae7">00195</a>   <span class="keywordtype">void</span> <a class="code" href="classGeographicLib_1_1TransverseMercator.html#07d73a6d94e2434cbb937978d61a5ae7">TransverseMercator::Forward</a>(real lon0, real lat, real lon,
<a name="l00196"></a>00196                                    real&amp; x, real&amp; y, real&amp; gamma, real&amp; k)
<a name="l00197"></a>00197     <span class="keyword">const</span> <span class="keywordflow">throw</span>() {
<a name="l00198"></a>00198     <span class="comment">// Avoid losing a bit of accuracy in lon (assuming lon0 is an integer)</span>
<a name="l00199"></a>00199     <span class="keywordflow">if</span> (lon - lon0 &gt; 180)
<a name="l00200"></a>00200       lon -= lon0 - 360;
<a name="l00201"></a>00201     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lon - lon0 &lt;= -180)
<a name="l00202"></a>00202       lon -= lon0 + 360;
<a name="l00203"></a>00203     <span class="keywordflow">else</span>
<a name="l00204"></a>00204       lon -= lon0;
<a name="l00205"></a>00205     <span class="comment">// Now lon in (-180, 180]</span>
<a name="l00206"></a>00206     <span class="comment">// Explicitly enforce the parity</span>
<a name="l00207"></a>00207     <span class="keywordtype">int</span>
<a name="l00208"></a>00208       latsign = lat &lt; 0 ? -1 : 1,
<a name="l00209"></a>00209       lonsign = lon &lt; 0 ? -1 : 1;
<a name="l00210"></a>00210     lon *= lonsign;
<a name="l00211"></a>00211     lat *= latsign;
<a name="l00212"></a>00212     <span class="keywordtype">bool</span> backside = lon &gt; 90;
<a name="l00213"></a>00213     <span class="keywordflow">if</span> (backside) {
<a name="l00214"></a>00214       <span class="keywordflow">if</span> (lat == 0)
<a name="l00215"></a>00215         latsign = -1;
<a name="l00216"></a>00216       lon = 180 - lon;
<a name="l00217"></a>00217     }
<a name="l00218"></a>00218     real
<a name="l00219"></a>00219       phi = lat * <a class="code" href="classGeographicLib_1_1Constants.html#26ff02acd8141a815428cddf0ff3ff66">Constants::degree</a>(),
<a name="l00220"></a>00220       lam = lon * <a class="code" href="classGeographicLib_1_1Constants.html#26ff02acd8141a815428cddf0ff3ff66">Constants::degree</a>();
<a name="l00221"></a>00221     <span class="comment">// q is isometric latitude</span>
<a name="l00222"></a>00222     <span class="comment">// JHS 154 has</span>
<a name="l00223"></a>00223     <span class="comment">//</span>
<a name="l00224"></a>00224     <span class="comment">//   beta = atan(sinh(q)) = conformal latitude</span>
<a name="l00225"></a>00225     <span class="comment">//   [xi', eta'] = Gauss-Schreiber TM coordinates</span>
<a name="l00226"></a>00226     <span class="comment">//   eta' = atanh(cos(beta) * sin(lam))</span>
<a name="l00227"></a>00227     <span class="comment">//   xi' = asin(sin(beta)*cosh(eta')</span>
<a name="l00228"></a>00228     <span class="comment">//</span>
<a name="l00229"></a>00229     <span class="comment">// We use</span>
<a name="l00230"></a>00230     <span class="comment">//</span>
<a name="l00231"></a>00231     <span class="comment">//   tan(beta) = sinh(q)</span>
<a name="l00232"></a>00232     <span class="comment">//   sin(beta) = tanh(q)</span>
<a name="l00233"></a>00233     <span class="comment">//   cos(beta) = sech(q)</span>
<a name="l00234"></a>00234     <span class="comment">//   denom^2    = 1-cos(beta)^2*sin(lam)^2 = 1-sech(q)^2*sin(lam)^2</span>
<a name="l00235"></a>00235     <span class="comment">//   sin(xip)   = sin(beta)/denom          = tanh(q)/denom</span>
<a name="l00236"></a>00236     <span class="comment">//   cos(xip)   = cos(beta)*cos(lam)/denom = sech(q)*cos(lam)/denom</span>
<a name="l00237"></a>00237     <span class="comment">//   cosh(etap) = 1/denom                  = 1/denom</span>
<a name="l00238"></a>00238     <span class="comment">//   sinh(etap) = cos(beta)*sin(lam)/denom = sech(q)*sin(lam)/denom</span>
<a name="l00239"></a>00239     <span class="comment">//</span>
<a name="l00240"></a>00240     <span class="comment">// to eliminate beta and derive more stable expressions for xi',eta'</span>
<a name="l00241"></a>00241     real etap, xip;
<a name="l00242"></a>00242     <span class="keywordflow">if</span> (lat &lt; 90) {
<a name="l00243"></a>00243       real
<a name="l00244"></a>00244         qp = <a class="code" href="classGeographicLib_1_1Math.html#1271a86b5bbe764c3a1ac4fdee2a2dab">Math::asinh</a>(tan(phi)),
<a name="l00245"></a>00245         q = qp - eatanhe(sin(phi));
<a name="l00246"></a>00246       xip = atan2(sinh(q), cos(lam));
<a name="l00247"></a>00247       etap = <a class="code" href="classGeographicLib_1_1Math.html#fd1fced228b796061c72fd4afa842728">Math::atanh</a>(sin(lam) / cosh(q));
<a name="l00248"></a>00248       <span class="comment">// convergence and scale for Gauss-Schreiber TM (xip, etap) -- gamma0 =</span>
<a name="l00249"></a>00249       <span class="comment">// atan(tan(xip) * tanh(etap)) = atan(tan(lam) * sin(beta))</span>
<a name="l00250"></a>00250       gamma = atan(tan(lam) * tanh(q));
<a name="l00251"></a>00251       <span class="comment">// k0 = sqrt(1 - _e2 * sin(phi)^2) * (cos(beta) / cos(phi)) * cosh(etap)</span>
<a name="l00252"></a>00252       <span class="comment">// Note 1/cos(phi) = cosh(qp);</span>
<a name="l00253"></a>00253       <span class="comment">// and cos(beta) * cosh(etap) = 1/hypot(sinh(q), cos(lam))</span>
<a name="l00254"></a>00254       k = sqrt(_e2m + _e2 * sq(cos(phi))) * cosh(qp) /
<a name="l00255"></a>00255         <a class="code" href="classGeographicLib_1_1Math.html#cdb3b600c45fbe2688efd8f733afda9d">Math::hypot</a>(sinh(q), cos(lam));
<a name="l00256"></a>00256     } <span class="keywordflow">else</span> {
<a name="l00257"></a>00257       xip = <a class="code" href="classGeographicLib_1_1Constants.html#7db7f25653721739d057673f7530ff14">Constants::pi</a>()/2;
<a name="l00258"></a>00258       etap = 0;
<a name="l00259"></a>00259       gamma = lam;
<a name="l00260"></a>00260       k = _c;
<a name="l00261"></a>00261     }
<a name="l00262"></a>00262     <span class="comment">// {xi',eta'} is {northing,easting} for Gauss-Schreiber transverse Mercator</span>
<a name="l00263"></a>00263     <span class="comment">// (for eta' = 0, xi' = bet). {xi,eta} is {northing,easting} for transverse</span>
<a name="l00264"></a>00264     <span class="comment">// Mercator with constant scale on the central meridian (for eta = 0, xip =</span>
<a name="l00265"></a>00265     <span class="comment">// rectifying latitude).  Define</span>
<a name="l00266"></a>00266     <span class="comment">//</span>
<a name="l00267"></a>00267     <span class="comment">//   zeta = xi + i*eta</span>
<a name="l00268"></a>00268     <span class="comment">//   zeta' = xi' + i*eta'</span>
<a name="l00269"></a>00269     <span class="comment">//</span>
<a name="l00270"></a>00270     <span class="comment">// The conversion from conformal to rectifying latitude can be expresses as</span>
<a name="l00271"></a>00271     <span class="comment">// a series in _n:</span>
<a name="l00272"></a>00272     <span class="comment">//</span>
<a name="l00273"></a>00273     <span class="comment">//   zeta = zeta' + sum(h[j-1]' * sin(2 * j * zeta'), j = 1..maxpow)</span>
<a name="l00274"></a>00274     <span class="comment">//</span>
<a name="l00275"></a>00275     <span class="comment">// where h[j]' = O(_n^j).  The reversion of this series gives</span>
<a name="l00276"></a>00276     <span class="comment">//</span>
<a name="l00277"></a>00277     <span class="comment">//   zeta' = zeta - sum(h[j-1] * sin(2 * j * zeta), j = 1..maxpow)</span>
<a name="l00278"></a>00278     <span class="comment">//</span>
<a name="l00279"></a>00279     <span class="comment">// which is used in Reverse.</span>
<a name="l00280"></a>00280     <span class="comment">//</span>
<a name="l00281"></a>00281     <span class="comment">// Evaluate sums via Clenshaw method.  See</span>
<a name="l00282"></a>00282     <span class="comment">//    http://mathworld.wolfram.com/ClenshawRecurrenceFormula.html</span>
<a name="l00283"></a>00283     <span class="comment">//</span>
<a name="l00284"></a>00284     <span class="comment">// Let</span>
<a name="l00285"></a>00285     <span class="comment">//</span>
<a name="l00286"></a>00286     <span class="comment">//    S = sum(c[k] * F[k](x), k = 0..N)</span>
<a name="l00287"></a>00287     <span class="comment">//    F[n+1](x) = alpha(n,x) * F[n](x) + beta(n,x) * F[n-1](x)</span>
<a name="l00288"></a>00288     <span class="comment">//</span>
<a name="l00289"></a>00289     <span class="comment">// Evaluate S with</span>
<a name="l00290"></a>00290     <span class="comment">//</span>
<a name="l00291"></a>00291     <span class="comment">//    y[N+2] = y[N+1] = 0</span>
<a name="l00292"></a>00292     <span class="comment">//    y[k] = alpha(k,x) * y[k+1] + beta(k+1,x) * y[k+2] + c[k]</span>
<a name="l00293"></a>00293     <span class="comment">//    S = c[0] * F[0](x) + y[1] * F[1](x) + beta(1,x) * F[0](x) * y[2]</span>
<a name="l00294"></a>00294     <span class="comment">//</span>
<a name="l00295"></a>00295     <span class="comment">// Here we have</span>
<a name="l00296"></a>00296     <span class="comment">//</span>
<a name="l00297"></a>00297     <span class="comment">//    x = 2 * zeta'</span>
<a name="l00298"></a>00298     <span class="comment">//    F[n](x) = sin(n * x)</span>
<a name="l00299"></a>00299     <span class="comment">//    a(n, x) = 2 * cos(x)</span>
<a name="l00300"></a>00300     <span class="comment">//    b(n, x) = -1</span>
<a name="l00301"></a>00301     <span class="comment">//    [ sin(A+B) - 2*cos(B)*sin(A) + sin(A-B) = 0, A = n*x, B = x ]</span>
<a name="l00302"></a>00302     <span class="comment">//    N = maxpow</span>
<a name="l00303"></a>00303     <span class="comment">//    c[k] = _hp[k-1]</span>
<a name="l00304"></a>00304     <span class="comment">//    S = y[1] * sin(x)</span>
<a name="l00305"></a>00305     <span class="comment">//</span>
<a name="l00306"></a>00306     <span class="comment">// For the derivative we have</span>
<a name="l00307"></a>00307     <span class="comment">//</span>
<a name="l00308"></a>00308     <span class="comment">//    x = 2 * zeta'</span>
<a name="l00309"></a>00309     <span class="comment">//    F[n](x) = cos(n * x)</span>
<a name="l00310"></a>00310     <span class="comment">//    a(n, x) = 2 * cos(x)</span>
<a name="l00311"></a>00311     <span class="comment">//    b(n, x) = -1</span>
<a name="l00312"></a>00312     <span class="comment">//    [ cos(A+B) - 2*cos(B)*cos(A) + cos(A-B) = 0, A = n*x, B = x ]</span>
<a name="l00313"></a>00313     <span class="comment">//    c[0] = 1; c[k] = 2*k*_hp[k-1]</span>
<a name="l00314"></a>00314     <span class="comment">//    S = (c[0] - y[2]) + y[1] * cos(x)</span>
<a name="l00315"></a>00315     real
<a name="l00316"></a>00316       c0 = cos(2 * xip), ch0 = cosh(2 * etap),
<a name="l00317"></a>00317       s0 = sin(2 * xip), sh0 = sinh(2 * etap),
<a name="l00318"></a>00318       ar = 2 * c0 * ch0, ai = -2 * s0 * sh0; <span class="comment">// 2 * cos(2*zeta')</span>
<a name="l00319"></a>00319     <span class="keywordtype">int</span> n = maxpow;
<a name="l00320"></a>00320     real
<a name="l00321"></a>00321       xi0 = (n &amp; 1 ? _hp[n - 1] : 0), eta0 = 0,
<a name="l00322"></a>00322       xi1 = 0, eta1 = 0;
<a name="l00323"></a>00323     real                        <span class="comment">// Accumulators for dzeta/dzeta'</span>
<a name="l00324"></a>00324       yr0 = (n &amp; 1 ? 2 * maxpow * _hp[--n] : 0), yi0 = 0,
<a name="l00325"></a>00325       yr1 = 0, yi1 = 0;
<a name="l00326"></a>00326     <span class="keywordflow">while</span> (n) {
<a name="l00327"></a>00327       --n;
<a name="l00328"></a>00328       xi1  = ar * xi0 - ai * eta0 - xi1 + _hp[n];
<a name="l00329"></a>00329       eta1 = ai * xi0 + ar * eta0 - eta1;
<a name="l00330"></a>00330       yr1 = ar * yr0 - ai * yi0 - yr1 + 2 * (n + 1) * _hp[n];
<a name="l00331"></a>00331       yi1 = ai * yr0 + ar * yi0 - yi1;
<a name="l00332"></a>00332       --n;
<a name="l00333"></a>00333       xi0  = ar * xi1 - ai * eta1 - xi0 + _hp[n];
<a name="l00334"></a>00334       eta0 = ai * xi1 + ar * eta1 - eta0;
<a name="l00335"></a>00335       yr0 = ar * yr1 - ai * yi1 - yr0 + 2 * (n + 1) * _hp[n];
<a name="l00336"></a>00336       yi0 = ai * yr1 + ar * yi1 - yi0;
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338     ar /= 2; ai /= 2;           <span class="comment">// cos(2*zeta')</span>
<a name="l00339"></a>00339     yr1 = 1 - yr1 + ar * yr0 - ai * yi0;
<a name="l00340"></a>00340     yi1 =   - yi1 + ai * yr0 + ar * yi0;
<a name="l00341"></a>00341     ar = s0 * ch0; ai = c0 * sh0; <span class="comment">// sin(2*zeta')</span>
<a name="l00342"></a>00342     real
<a name="l00343"></a>00343       xi  = xip  + ar * xi0 - ai * eta0,
<a name="l00344"></a>00344       eta = etap + ai * xi0 + ar * eta0;
<a name="l00345"></a>00345     <span class="comment">// Fold in change in convergence and scale for Gauss-Schreiber TM to</span>
<a name="l00346"></a>00346     <span class="comment">// Gauss-Krueger TM.</span>
<a name="l00347"></a>00347     gamma -= atan2(yi1, yr1);
<a name="l00348"></a>00348     k *= _b1 * <a class="code" href="classGeographicLib_1_1Math.html#cdb3b600c45fbe2688efd8f733afda9d">Math::hypot</a>(yr1, yi1);
<a name="l00349"></a>00349     gamma /= Constants::degree();
<a name="l00350"></a>00350     y = _a1 * _k0 * (backside ? <a class="code" href="classGeographicLib_1_1Constants.html#7db7f25653721739d057673f7530ff14">Constants::pi</a>() - xi : xi) * latsign;
<a name="l00351"></a>00351     x = _a1 * _k0 * eta * lonsign;
<a name="l00352"></a>00352     <span class="keywordflow">if</span> (backside)
<a name="l00353"></a>00353       gamma = 180 - gamma;
<a name="l00354"></a>00354     gamma *= latsign * lonsign;
<a name="l00355"></a>00355     k *= _k0;
<a name="l00356"></a>00356   }
<a name="l00357"></a>00357 
<a name="l00358"></a><a class="code" href="classGeographicLib_1_1TransverseMercator.html#15611aee4e3707e155278bab02403a07">00358</a>   <span class="keywordtype">void</span> <a class="code" href="classGeographicLib_1_1TransverseMercator.html#15611aee4e3707e155278bab02403a07">TransverseMercator::Reverse</a>(real lon0, real x, real y,
<a name="l00359"></a>00359                                    real&amp; lat, real&amp; lon, real&amp; gamma, real&amp; k)
<a name="l00360"></a>00360     <span class="keyword">const</span> <span class="keywordflow">throw</span>() {
<a name="l00361"></a>00361     <span class="comment">// This undoes the steps in Forward.  The wrinkles are: (1) Use of the</span>
<a name="l00362"></a>00362     <span class="comment">// reverted series to express zeta' in terms of zeta. (2) Newton's method</span>
<a name="l00363"></a>00363     <span class="comment">// to solve for phi in terms of q.</span>
<a name="l00364"></a>00364     real
<a name="l00365"></a>00365       xi = y / (_a1 * _k0),
<a name="l00366"></a>00366       eta = x / (_a1 * _k0);
<a name="l00367"></a>00367     <span class="comment">// Explicitly enforce the parity</span>
<a name="l00368"></a>00368     <span class="keywordtype">int</span>
<a name="l00369"></a>00369       xisign = xi &lt; 0 ? -1 : 1,
<a name="l00370"></a>00370       etasign = eta &lt; 0 ? -1 : 1;
<a name="l00371"></a>00371     xi *= xisign;
<a name="l00372"></a>00372     eta *= etasign;
<a name="l00373"></a>00373     <span class="keywordtype">bool</span> backside = xi &gt; <a class="code" href="classGeographicLib_1_1Constants.html#7db7f25653721739d057673f7530ff14">Constants::pi</a>()/2;
<a name="l00374"></a>00374     <span class="keywordflow">if</span> (backside)
<a name="l00375"></a>00375       xi = <a class="code" href="classGeographicLib_1_1Constants.html#7db7f25653721739d057673f7530ff14">Constants::pi</a>() - xi;
<a name="l00376"></a>00376     real
<a name="l00377"></a>00377       c0 = cos(2 * xi), ch0 = cosh(2 * eta),
<a name="l00378"></a>00378       s0 = sin(2 * xi), sh0 = sinh(2 * eta),
<a name="l00379"></a>00379       ar = 2 * c0 * ch0, ai = -2 * s0 * sh0; <span class="comment">// 2 * cos(2*zeta)</span>
<a name="l00380"></a>00380     <span class="keywordtype">int</span> n = maxpow;
<a name="l00381"></a>00381     real                        <span class="comment">// Accumulators for zeta'</span>
<a name="l00382"></a>00382       xip0 = (n &amp; 1 ? -_h[n - 1] : 0), etap0 = 0,
<a name="l00383"></a>00383       xip1 = 0, etap1 = 0;
<a name="l00384"></a>00384     real                        <span class="comment">// Accumulators for dzeta'/dzeta</span>
<a name="l00385"></a>00385       yr0 = (n &amp; 1 ? - 2 * maxpow * _h[--n] : 0), yi0 = 0,
<a name="l00386"></a>00386       yr1 = 0, yi1 = 0;
<a name="l00387"></a>00387     <span class="keywordflow">while</span> (n) {
<a name="l00388"></a>00388       --n;
<a name="l00389"></a>00389       xip1  = ar * xip0 - ai * etap0 - xip1 - _h[n];
<a name="l00390"></a>00390       etap1 = ai * xip0 + ar * etap0 - etap1;
<a name="l00391"></a>00391       yr1 = ar * yr0 - ai * yi0 - yr1 - 2 * (n + 1) * _h[n];
<a name="l00392"></a>00392       yi1 = ai * yr0 + ar * yi0 - yi1;
<a name="l00393"></a>00393       --n;
<a name="l00394"></a>00394       xip0  = ar * xip1 - ai * etap1 - xip0 - _h[n];
<a name="l00395"></a>00395       etap0 = ai * xip1 + ar * etap1 - etap0;
<a name="l00396"></a>00396       yr0 = ar * yr1 - ai * yi1 - yr0 - 2 * (n + 1) * _h[n];
<a name="l00397"></a>00397       yi0 = ai * yr1 + ar * yi1 - yi0;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399     ar /= 2; ai /= 2;           <span class="comment">// cos(2*zeta')</span>
<a name="l00400"></a>00400     yr1 = 1 - yr1 + ar * yr0 - ai * yi0;
<a name="l00401"></a>00401     yi1 =   - yi1 + ai * yr0 + ar * yi0;
<a name="l00402"></a>00402     ar = s0 * ch0; ai = c0 * sh0; <span class="comment">// sin(2*zeta)</span>
<a name="l00403"></a>00403     real
<a name="l00404"></a>00404       xip  = xi  + ar * xip0 - ai * etap0,
<a name="l00405"></a>00405       etap = eta + ai * xip0 + ar * etap0;
<a name="l00406"></a>00406     <span class="comment">// Convergence and scale for Gauss-Schreiber TM to Gauss-Krueger TM.</span>
<a name="l00407"></a>00407     gamma = atan2(yi1, yr1);
<a name="l00408"></a>00408     k = _b1 / <a class="code" href="classGeographicLib_1_1Math.html#cdb3b600c45fbe2688efd8f733afda9d">Math::hypot</a>(yr1, yi1);
<a name="l00409"></a>00409     <span class="comment">// JHS 154 has</span>
<a name="l00410"></a>00410     <span class="comment">//</span>
<a name="l00411"></a>00411     <span class="comment">//   beta = asin(sin(xip) / cosh(etap))</span>
<a name="l00412"></a>00412     <span class="comment">//   lam = asin(tanh(etap) / cos(beta)</span>
<a name="l00413"></a>00413     <span class="comment">//   q = asinh(tan(beta))</span>
<a name="l00414"></a>00414     <span class="comment">//</span>
<a name="l00415"></a>00415     <span class="comment">// the following eliminates beta and is more stable</span>
<a name="l00416"></a>00416     real lam, phi;
<a name="l00417"></a>00417     real
<a name="l00418"></a>00418       s = sinh(etap),
<a name="l00419"></a>00419       c = cos(xip),
<a name="l00420"></a>00420       r = <a class="code" href="classGeographicLib_1_1Math.html#cdb3b600c45fbe2688efd8f733afda9d">Math::hypot</a>(s, c);
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (r &gt; 0) {
<a name="l00422"></a>00422       lam = atan2(s, c);
<a name="l00423"></a>00423       <span class="comment">// Use Newton's method to solve</span>
<a name="l00424"></a>00424       <span class="comment">// q = qp - e * atanh(e * tanh(qp))</span>
<a name="l00425"></a>00425       <span class="comment">// for qp = asinh(tan(phi))</span>
<a name="l00426"></a>00426       real
<a name="l00427"></a>00427         q = <a class="code" href="classGeographicLib_1_1Math.html#1271a86b5bbe764c3a1ac4fdee2a2dab">Math::asinh</a>(sin(xip)/r),
<a name="l00428"></a>00428         qp = q;
<a name="l00429"></a>00429       <span class="comment">// min iterations = 1, max iterations = 3; mean = 2.8</span>
<a name="l00430"></a>00430       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numit; ++i) {
<a name="l00431"></a>00431         real
<a name="l00432"></a>00432           t = tanh(qp),
<a name="l00433"></a>00433           dqp = -(qp - eatanhe(t) - q) * (1 - _e2 * sq(t)) / _e2m;
<a name="l00434"></a>00434         qp += dqp;
<a name="l00435"></a>00435         <span class="keywordflow">if</span> (abs(dqp) &lt; tol)
<a name="l00436"></a>00436           <span class="keywordflow">break</span>;
<a name="l00437"></a>00437       }
<a name="l00438"></a>00438       phi = atan(sinh(qp));
<a name="l00439"></a>00439       gamma += atan(tan(xip) * tanh(etap));
<a name="l00440"></a>00440       <span class="comment">// Note cos(beta) * cosh(etap) = r</span>
<a name="l00441"></a>00441       k *= sqrt(_e2m + _e2 * sq(cos(phi))) * cosh(qp) * r;
<a name="l00442"></a>00442     } <span class="keywordflow">else</span> {
<a name="l00443"></a>00443       phi = <a class="code" href="classGeographicLib_1_1Constants.html#7db7f25653721739d057673f7530ff14">Constants::pi</a>()/2;
<a name="l00444"></a>00444       lam = 0;
<a name="l00445"></a>00445       k *= _c;
<a name="l00446"></a>00446     }
<a name="l00447"></a>00447     lat = phi / <a class="code" href="classGeographicLib_1_1Constants.html#26ff02acd8141a815428cddf0ff3ff66">Constants::degree</a>() * xisign;
<a name="l00448"></a>00448     lon = lam / <a class="code" href="classGeographicLib_1_1Constants.html#26ff02acd8141a815428cddf0ff3ff66">Constants::degree</a>();
<a name="l00449"></a>00449     <span class="keywordflow">if</span> (backside)
<a name="l00450"></a>00450       lon = 180 - lon;
<a name="l00451"></a>00451     lon *= etasign;
<a name="l00452"></a>00452     <span class="comment">// Avoid losing a bit of accuracy in lon (assuming lon0 is an integer)</span>
<a name="l00453"></a>00453     <span class="keywordflow">if</span> (lon + lon0 &gt;= 180)
<a name="l00454"></a>00454       lon += lon0 - 360;
<a name="l00455"></a>00455     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (lon + lon0 &lt; -180)
<a name="l00456"></a>00456       lon += lon0 + 360;
<a name="l00457"></a>00457     <span class="keywordflow">else</span>
<a name="l00458"></a>00458       lon += lon0;
<a name="l00459"></a>00459     gamma /= <a class="code" href="classGeographicLib_1_1Constants.html#26ff02acd8141a815428cddf0ff3ff66">Constants::degree</a>();
<a name="l00460"></a>00460     <span class="keywordflow">if</span> (backside)
<a name="l00461"></a>00461       gamma = 180 - gamma;
<a name="l00462"></a>00462     gamma *= xisign * etasign;
<a name="l00463"></a>00463     k *= _k0;
<a name="l00464"></a>00464   }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 } <span class="comment">// namespace GeographicLib</span>
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 7 00:46:28 2010 for GeographicLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
